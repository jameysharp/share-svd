extern crate svd_parser;

use std::collections::BTreeMap;
use std::env::args;
use std::fs::File;
use std::io;

fn main() {
    let devices = load_devices().expect("failed to parse input files");
    let peripherals = devices.into_iter()
        .flat_map(|svd_parser::Device { defaults, peripherals, .. }| {
            peripherals.into_iter()
                .flat_map(move |peripheral| {
                    let name = peripheral.group_name.unwrap_or(peripheral.name);
                    peripheral.registers.map(move |registers|
                        Ok((Peripheral::new(registers, &defaults)?, name))
                    )
                })
        })
        .collect::<Result<BTreeMap<Peripheral, String>, String>>()
        .unwrap();
    for (_, name) in peripherals {
        println!("{}", name);
    }
}

fn load_devices() -> io::Result<Vec<svd_parser::Device>> {
    args().skip(1).map(|filename| {
        use std::io::Read;
        let mut xml = String::new();
        File::open(filename)?.read_to_string(&mut xml)?;
        Ok(svd_parser::parse(xml.as_ref()))
    }).collect()
}

#[derive(Ord, Eq, PartialOrd, PartialEq)]
struct BitRange {
    pub offset: u32,
    pub width: u32,
}

impl From<svd_parser::BitRange> for BitRange {
    fn from(other: svd_parser::BitRange) -> BitRange {
        BitRange {
            offset: other.offset,
            width: other.width,
        }
    }
}

#[derive(Ord, Eq, PartialOrd, PartialEq)]
struct Access(pub u32);

impl From<svd_parser::Access> for Access {
    fn from(access: svd_parser::Access) -> Access {
        Access(access as u32)
    }
}

#[derive(Ord, Eq, PartialOrd, PartialEq)]
struct Field {
    // field name is part of the Rust types generated by svd2rust
    pub name: String,

    // ignore description

    // if bit_range is different, the field implementation is
    // incompatible
    pub bit_range: BitRange,

    // according to CMSIS spec, access must have been defined by
    // register level at the latest, so this doesn't need to be an
    // Option
    pub access: Access,

    // ignore enumerated_values because a field with enum values can be
    // freely substituted in place of one without

    // ignore write_constraint
    // XXX: is this good?
}

impl Field {
    pub fn new(field: svd_parser::Field, default_access: Option<svd_parser::Access>) -> Result<Field, String> {
        Ok(Field {
            name: field.name.clone(),
            bit_range: field.bit_range.into(),
            access: field.access.or(default_access)
                .ok_or_else(|| format!("missing access for {}", field.name))?
                .into(),
        })
    }
}

#[derive(Ord, Eq, PartialOrd, PartialEq)]
struct RegisterInfo {
    // register name is part of the Rust types generated by svd2rust
    pub name: String,

    // ignore description

    pub address_offset: u32,

    pub size: u32,

    // access is pushed down into individual fields

    pub reset_value: u32,

    pub reset_mask: u32,

    pub fields: Option<Vec<Field>>,

    // ignore write_constraint
    // XXX: is this good?
}

impl RegisterInfo {
    pub fn new(register: svd_parser::RegisterInfo, defaults: &svd_parser::Defaults) -> Result<RegisterInfo, String> {
        let name = register.name;
        let default_access = register.access.or(defaults.access);
        Ok(RegisterInfo {
            name: name.clone(),
            address_offset: register.address_offset,
            size: register.size.or(defaults.size)
                .ok_or_else(|| format!("missing size in {}", name))?,
            reset_value: register.reset_value.or(defaults.reset_value)
                .ok_or_else(|| format!("missing reset value in {}", name))?,
            reset_mask: register.reset_mask.or(defaults.reset_mask)
                .ok_or_else(|| format!("missing reset mask in {}", name))?,
            fields: match register.fields {
                    Some(fields) => Some(
                        fields.into_iter()
                            .map(|field| Field::new(field, default_access))
                            .collect::<Result<Vec<Field>, String>>()?
                    ),
                    None => None,
                },
        })
    }
}

// FIXME: assuming arrays with the same base element are equal
#[derive(Ord, Eq, PartialOrd, PartialEq)]
struct Peripheral(Vec<RegisterInfo>);

impl Peripheral {
    pub fn new(registers: Vec<svd_parser::Register>, defaults: &svd_parser::Defaults) -> Result<Peripheral, String> {
        registers.into_iter()
            .map(|register| RegisterInfo::new(match register {
                svd_parser::Register::Single(info) => info,
                svd_parser::Register::Array(info, _) => info,
            }, defaults))
            .collect::<Result<Vec<RegisterInfo>, String>>()
            .map(Peripheral)
    }
}
